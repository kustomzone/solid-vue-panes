{"version":3,"sources":["webpack:///./node_modules/base64-js/index.js","webpack:///./node_modules/n3/src/N3Parser.js","webpack:///./node_modules/queue-microtask/index.js","webpack:///./node_modules/ieee754/index.js","webpack:///./node_modules/n3/src/N3DataFactory.js","webpack:///./node_modules/n3/src/N3Writer.js","webpack:///./node_modules/n3/src/N3Util.js","webpack:///./node_modules/buffer/index.js","webpack:///./node_modules/http-link-header/lib/link.js","webpack:///./node_modules/isarray/index.js","webpack:///./node_modules/n3/src/N3Lexer.js","webpack:///./node_modules/n3/src/IRIs.js"],"names":["exports","byteLength","toByteArray","fromByteArray","lookup","revLookup","Arr","Uint8Array","Array","code","i","len","length","charCodeAt","getLens","b64","Error","validLen","indexOf","placeHoldersLen","lens","_byteLength","tmp","arr","curByte","tripletToBase64","num","encodeChunk","uint8","start","end","output","push","join","extraBytes","parts","maxChunkLength","len2","blankNodePrefix","N3Parser","options","this","_contextStack","_graph","_setBase","baseIRI","factory","initDataFactory","format","match","toLowerCase","isTurtle","test","isTriG","isNTriples","isNQuads","isN3","_n3Mode","isLineMode","_supportsNamedGraphs","_readPredicateOrNamedGraph","_readPredicate","_supportsQuads","_supportsRDFStar","_resolveRelativeIRI","iri","_blankNodePrefix","replace","_lexer","lexer","lineMode","n3","_explicitQuantifiers","explicitQuantifiers","fragmentPos","substr","_base","_basePath","_baseRoot","_baseScheme","type","graph","subject","predicate","object","n3Mode","inverse","_inversePredicate","blankPrefix","_prefixes","_","quantified","_quantified","id","Object","create","context","pop","_subject","_predicate","_object","token","_error","_callback","_sparqlStyle","_readPrefix","_readBaseIRI","_readSubject","_readNamedGraphLabel","quantifier","value","_resolveIRI","_namedNode","prefix","undefined","_blankNode","_variable","_saveContext","_readBlankNodeHead","RDF_NIL","_readListItem","_readPunctuation","N3_FORSOME","_quantifier","_readQuantifierList","N3_FORALL","_literalValue","_completeSubjectLiteral","_literal","_readEntity","_getPathReader","ABBREVIATIONS","_readBlankNodeTail","_readObject","_readDataTypeOrLang","_getContextEndReader","_readGraph","_readBlankNodePunctuation","_emit","empty","_restoreContext","_readPredicateAfterBlank","item","list","previousList","stack","parent","next","RDF_FIRST","_readListItemDataTypeOrLang","RDF_REST","_completeObjectLiteral","literal","datatype","_completeLiteral","listItem","completed","_readCallback","inversePredicate","_readFormulaTail","_readInTopContext","_readQuadPunctuation","_prefix","_readPrefixIRI","prefixNode","_prefixCallback","_readDeclarationPunctuation","_readNamedGraphBlankLabel","entity","DEFAULTGRAPH","QUANTIFIERS_GRAPH","_readQuantifierPunctuation","afterPath","_afterPath","_readPath","_readForwardPath","_readBackwardPath","_readRDFStarTail","quad","_quad","contextStack","_readRDFStarTailOrGraph","message","err","line","previousToken","noop","_removeDotSegments","result","pathStart","segmentStart","substring","lastIndexOf","input","quadCallback","prefixCallback","self","error","quads","e","t","tokenize","every","parser","namedNode","blankNode","variable","defaultGraph","rdf","first","rest","nil","r","forAll","forSome","owl","sameAs","log","implies","prototype","promise","module","queueMicrotask","cb","Promise","resolve","then","catch","setTimeout","read","buffer","offset","isLE","mLen","nBytes","m","eLen","eMax","eBias","nBits","d","s","NaN","Infinity","Math","pow","write","c","rt","abs","isNaN","floor","LN2","xsd","_blankNodeCounter","escapedLiteral","quadId","DataFactory","triple","Term","other","termType","NamedNode","Literal","atPos","datatypeString","ch","dtPos","string","langString","language","BlankNode","name","super","Variable","DefaultGraph","termFromId","endPos","components","exec","unescapeQuotes","termToId","term","escapeQuotes","Quad","toJSON","equals","quoted","languageOrDataType","boolean","Number","isFinite","isInteger","integer","double","escape","escapeAll","escapedCharacters","SerializedTerm","N3Writer","outputStream","_prefixRegex","_lists","lists","_outputStream","_endStream","chunk","encoding","done","_writeQuad","_writeQuadLine","_prefixIRIs","prefixes","addPrefixes","callback","_write","_inDefaultGraph","_encodeIriOrBlank","_encodeObject","_encodePredicate","_encodeSubject","_prefixMatch","quadToString","map","_encodeQuad","characterReplacer","prefixMatch","_encodeLiteral","addQuad","prefixIRIs","hasPrefixes","IRIlist","prefixList","prefixIRI","RegExp","child","children","contents","elements","_blockedWrite","singleDone","character","toString","isDefaultGraph","base64","ieee754","isArray","typedArraySupport","__proto__","foo","subarray","kMaxLength","Buffer","TYPED_ARRAY_SUPPORT","createBuffer","that","RangeError","arg","encodingOrOffset","allocUnsafe","from","TypeError","ArrayBuffer","fromArrayBuffer","fromString","fromObject","assertSize","size","alloc","fill","checked","isEncoding","actual","slice","fromArrayLike","array","byteOffset","obj","isBuffer","copy","isnan","data","SlowBuffer","isView","loweredCase","utf8ToBytes","base64ToBytes","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","b","n","bidirectionalIndexOf","val","dir","arrayIndexOf","call","indexSize","arrLength","valLength","String","buf","readUInt16BE","foundIndex","found","j","hexWrite","remaining","strLen","parsed","parseInt","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","min","res","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","decodeCodePointsArray","INSPECT_MAX_BYTES","global","poolSize","_augment","Symbol","species","defineProperty","configurable","allocUnsafeSlow","_isBuffer","compare","a","x","y","concat","pos","swap16","swap32","swap64","arguments","apply","inspect","str","max","target","thisStart","thisEnd","thisCopy","targetCopy","includes","_arr","MAX_ARGUMENTS_LENGTH","codePoints","fromCharCode","ret","out","toHex","bytes","checkOffset","ext","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","writeDouble","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","maxBytes","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","set","INVALID_BASE64_RE","base64clean","stringtrim","trim","units","leadSurrogate","byteArray","hi","lo","src","dst","COMPATIBLE_ENCODING_PATTERN","WS_TRIM_PATTERN","WS_CHAR_PATTERN","WS_FOLD_PATTERN","DELIMITER_PATTERN","WS_DELIMITER_PATTERN","STATE","IDLE","URI","ATTR","hasWhitespace","skipWhitespace","needsQuotes","Link","refs","parse","links","rel","attr","link","state","ref","uri","attrValue","isSingleOccurenceAttr","parseExtendedValue","keys","reduce","formatAttribute","isCompatibleEncoding","isTokenAttr","decodeURIComponent","formatExtendedAttribute","toUpperCase","encodedValue","encodeURIComponent","escapeSequence","escapeReplacements","illegalIriChars","lineModeRegExps","_iri","_unescapedIri","_simpleQuotedString","_langcode","_blank","_newline","_comment","_whitespace","_endOfFile","invalidRegExp","N3Lexer","_simpleApostropheString","_prefixed","_number","_boolean","_keyword","_sparqlKeyword","_shortPredicates","_lineMode","key","_comments","comments","_literalClosingPos","inputFinished","_input","outputComments","whiteSpaceMatch","comment","_line","firstChar","matchLength","inconclusive","_previousMarker","_unescape","reportSyntaxError","_parseLiteral","decimal","_syntaxError","invalid","replaced","sequence","unicode4","unicode8","escapedChar","charCode","opening","openingLength","closingPos","backslashCount","raw","lines","split","issue","tokens","_tokenizeToEnd","_pendingBuffer","setEncoding","on","RDF","XSD","SWAP"],"mappings":"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","file":"js/chunk-ba0dcc44.ae2d8801.js","sourcesContent":["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","// **N3Parser** parses N3 documents.\nimport N3Lexer from './N3Lexer';\nimport N3DataFactory from './N3DataFactory';\nimport namespaces from './IRIs';\n\nlet blankNodePrefix = 0;\n\n// ## Constructor\nexport default class N3Parser {\n  constructor(options) {\n    this._contextStack = [];\n    this._graph = null;\n\n    // Set the document IRI\n    options = options || {};\n    this._setBase(options.baseIRI);\n    options.factory && initDataFactory(this, options.factory);\n\n    // Set supported features depending on the format\n    var format = (typeof options.format === 'string') ?\n                 options.format.match(/\\w*$/)[0].toLowerCase() : '',\n        isTurtle = /turtle/.test(format), isTriG = /trig/.test(format),\n        isNTriples = /triple/.test(format), isNQuads = /quad/.test(format),\n        isN3 = this._n3Mode = /n3/.test(format),\n        isLineMode = isNTriples || isNQuads;\n    if (!(this._supportsNamedGraphs = !(isTurtle || isN3)))\n      this._readPredicateOrNamedGraph = this._readPredicate;\n    // Support triples in other graphs\n    this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3);\n    // Support nesting of triples\n    this._supportsRDFStar = format === '' || /star|\\*$/.test(format);\n    // Disable relative IRIs in N-Triples or N-Quads mode\n    if (isLineMode)\n      this._resolveRelativeIRI = function (iri) { return null; };\n    this._blankNodePrefix = typeof options.blankNodePrefix !== 'string' ? '' :\n                              options.blankNodePrefix.replace(/^(?!_:)/, '_:');\n    this._lexer = options.lexer || new N3Lexer({ lineMode: isLineMode, n3: isN3 });\n    // Disable explicit quantifiers by default\n    this._explicitQuantifiers = !!options.explicitQuantifiers;\n  }\n\n  // ## Static class methods\n\n  // ### `_resetBlankNodePrefix` restarts blank node prefix identification\n  static _resetBlankNodePrefix() {\n    blankNodePrefix = 0;\n  }\n\n  // ## Private methods\n\n  // ### `_setBase` sets the base IRI to resolve relative IRIs\n  _setBase(baseIRI) {\n    if (!baseIRI) {\n      this._base = '';\n      this._basePath = '';\n    }\n    else {\n      // Remove fragment if present\n      var fragmentPos = baseIRI.indexOf('#');\n      if (fragmentPos >= 0)\n        baseIRI = baseIRI.substr(0, fragmentPos);\n      // Set base IRI and its components\n      this._base = baseIRI;\n      this._basePath   = baseIRI.indexOf('/') < 0 ? baseIRI :\n                         baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');\n      baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i);\n      this._baseRoot   = baseIRI[0];\n      this._baseScheme = baseIRI[1];\n    }\n  }\n\n  // ### `_saveContext` stores the current parsing context\n  // when entering a new scope (list, blank node, formula)\n  _saveContext(type, graph, subject, predicate, object) {\n    var n3Mode = this._n3Mode;\n    this._contextStack.push({\n      subject: subject, predicate: predicate, object: object,\n      graph: graph, type: type,\n      inverse: n3Mode ? this._inversePredicate : false,\n      blankPrefix: n3Mode ? this._prefixes._ : '',\n      quantified: n3Mode ? this._quantified : null,\n    });\n    // The settings below only apply to N3 streams\n    if (n3Mode) {\n      // Every new scope resets the predicate direction\n      this._inversePredicate = false;\n      // In N3, blank nodes are scoped to a formula\n      // (using a dot as separator, as a blank node label cannot start with it)\n      this._prefixes._ = (this._graph ? this._graph.id.substr(2) + '.' : '.');\n      // Quantifiers are scoped to a formula\n      this._quantified = Object.create(this._quantified);\n    }\n  }\n\n  // ### `_restoreContext` restores the parent context\n  // when leaving a scope (list, blank node, formula)\n  _restoreContext() {\n    var context = this._contextStack.pop(), n3Mode = this._n3Mode;\n    this._subject   = context.subject;\n    this._predicate = context.predicate;\n    this._object    = context.object;\n    this._graph     = context.graph;\n    // The settings below only apply to N3 streams\n    if (n3Mode) {\n      this._inversePredicate = context.inverse;\n      this._prefixes._ = context.blankPrefix;\n      this._quantified = context.quantified;\n    }\n  }\n\n  // ### `_readInTopContext` reads a token when in the top context\n  _readInTopContext(token) {\n    switch (token.type) {\n    // If an EOF token arrives in the top context, signal that we're done\n    case 'eof':\n      if (this._graph !== null)\n        return this._error('Unclosed graph', token);\n      delete this._prefixes._;\n      return this._callback(null, null, this._prefixes);\n    // It could be a prefix declaration\n    case 'PREFIX':\n      this._sparqlStyle = true;\n    case '@prefix':\n      return this._readPrefix;\n    // It could be a base declaration\n    case 'BASE':\n      this._sparqlStyle = true;\n    case '@base':\n      return this._readBaseIRI;\n    // It could be a graph\n    case '{':\n      if (this._supportsNamedGraphs) {\n        this._graph = '';\n        this._subject = null;\n        return this._readSubject;\n      }\n    case 'GRAPH':\n      if (this._supportsNamedGraphs)\n        return this._readNamedGraphLabel;\n    // Otherwise, the next token must be a subject\n    default:\n      return this._readSubject(token);\n    }\n  }\n\n  // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable\n  _readEntity(token, quantifier) {\n    var value;\n    switch (token.type) {\n    // Read a relative or absolute IRI\n    case 'IRI':\n    case 'typeIRI':\n      var iri = this._resolveIRI(token.value);\n      if (iri === null)\n        return this._error('Invalid IRI', token);\n      value = this._namedNode(iri);\n      break;\n    // Read a prefixed name\n    case 'type':\n    case 'prefixed':\n      var prefix = this._prefixes[token.prefix];\n      if (prefix === undefined)\n        return this._error('Undefined prefix \"' + token.prefix + ':\"', token);\n      value = this._namedNode(prefix + token.value);\n      break;\n    // Read a blank node\n    case 'blank':\n      value = this._blankNode(this._prefixes[token.prefix] + token.value);\n      break;\n    // Read a variable\n    case 'var':\n      value = this._variable(token.value.substr(1));\n      break;\n    // Everything else is not an entity\n    default:\n      return this._error('Expected entity but got ' + token.type, token);\n    }\n    // In N3 mode, replace the entity if it is quantified\n    if (!quantifier && this._n3Mode && (value.id in this._quantified))\n      value = this._quantified[value.id];\n    return value;\n  }\n\n  // ### `_readSubject` reads a quad's subject\n  _readSubject(token) {\n    this._predicate = null;\n    switch (token.type) {\n    case '[':\n      // Start a new quad with a new blank node as subject\n      this._saveContext('blank', this._graph,\n                        this._subject = this._blankNode(), null, null);\n      return this._readBlankNodeHead;\n    case '(':\n      // Start a new list\n      this._saveContext('list', this._graph, this.RDF_NIL, null, null);\n      this._subject = null;\n      return this._readListItem;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph,\n                        this._graph = this._blankNode(), null, null);\n      return this._readSubject;\n    case '}':\n       // No subject; the graph in which we are reading is closed instead\n      return this._readPunctuation(token);\n    case '@forSome':\n      if (!this._n3Mode)\n        return this._error('Unexpected \"@forSome\"', token);\n      this._subject = null;\n      this._predicate = this.N3_FORSOME;\n      this._quantifier = this._blankNode;\n      return this._readQuantifierList;\n    case '@forAll':\n      if (!this._n3Mode)\n        return this._error('Unexpected \"@forAll\"', token);\n      this._subject = null;\n      this._predicate = this.N3_FORALL;\n      this._quantifier = this._variable;\n      return this._readQuantifierList;\n    case 'literal':\n      if (!this._n3Mode)\n        return this._error('Unexpected literal', token);\n\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        return this._completeSubjectLiteral;\n      }\n      else\n        this._subject = this._literal(token.value, this._namedNode(token.prefix));\n\n      break;\n    case '<<':\n      if (!this._supportsRDFStar)\n        return this._error('Unexpected RDF* syntax', token);\n      this._saveContext('<<', this._graph, null, null, null);\n      this._graph = null;\n      return this._readSubject;\n    default:\n      // Read the subject entity\n      if ((this._subject = this._readEntity(token)) === undefined)\n        return;\n      // In N3 mode, the subject might be a path\n      if (this._n3Mode)\n        return this._getPathReader(this._readPredicateOrNamedGraph);\n    }\n\n    // The next token must be a predicate,\n    // or, if the subject was actually a graph IRI, a named graph\n    return this._readPredicateOrNamedGraph;\n  }\n\n  // ### `_readPredicate` reads a quad's predicate\n  _readPredicate(token) {\n    var type = token.type;\n    switch (type) {\n    case 'inverse':\n      this._inversePredicate = true;\n    case 'abbreviation':\n      this._predicate = this.ABBREVIATIONS[token.value];\n      break;\n    case '.':\n    case ']':\n    case '}':\n      // Expected predicate didn't come, must have been trailing semicolon\n      if (this._predicate === null)\n        return this._error('Unexpected ' + type, token);\n      this._subject = null;\n      return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);\n    case ';':\n      // Additional semicolons can be safely ignored\n      return this._predicate !== null ? this._readPredicate :\n             this._error('Expected predicate but got ;', token);\n    case 'blank':\n      if (!this._n3Mode)\n        return this._error('Disallowed blank node as predicate', token);\n    default:\n      if ((this._predicate = this._readEntity(token)) === undefined)\n        return;\n    }\n    // The next token must be an object\n    return this._readObject;\n  }\n\n  // ### `_readObject` reads a quad's object\n  _readObject(token) {\n    switch (token.type) {\n    case 'literal':\n      // Regular literal, can still get a datatype or language\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        return this._readDataTypeOrLang;\n      }\n      // Pre-datatyped string literal (prefix stores the datatype)\n      else\n        this._object = this._literal(token.value, this._namedNode(token.prefix));\n      break;\n    case '[':\n      // Start a new quad with a new blank node as subject\n      this._saveContext('blank', this._graph, this._subject, this._predicate,\n                        this._subject = this._blankNode());\n      return this._readBlankNodeHead;\n    case '(':\n      // Start a new list\n      this._saveContext('list', this._graph, this._subject, this._predicate, this.RDF_NIL);\n      this._subject = null;\n      return this._readListItem;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph, this._subject, this._predicate,\n                        this._graph = this._blankNode());\n      return this._readSubject;\n    case '<<':\n      if (!this._supportsRDFStar)\n        return this._error('Unexpected RDF* syntax', token);\n      this._saveContext('<<', this._graph, this._subject, this._predicate, null);\n      this._graph = null;\n      return this._readSubject;\n    default:\n      // Read the object entity\n      if ((this._object = this._readEntity(token)) === undefined)\n        return;\n      // In N3 mode, the object might be a path\n      if (this._n3Mode)\n        return this._getPathReader(this._getContextEndReader());\n    }\n    return this._getContextEndReader();\n  }\n\n  // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph\n  _readPredicateOrNamedGraph(token) {\n    return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);\n  }\n\n  // ### `_readGraph` reads a graph\n  _readGraph(token) {\n    if (token.type !== '{')\n      return this._error('Expected graph but got ' + token.type, token);\n    // The \"subject\" we read is actually the GRAPH's label\n    this._graph = this._subject, this._subject = null;\n    return this._readSubject;\n  }\n\n  // ### `_readBlankNodeHead` reads the head of a blank node\n  _readBlankNodeHead(token) {\n    if (token.type === ']') {\n      this._subject = null;\n      return this._readBlankNodeTail(token);\n    }\n    else {\n      this._predicate = null;\n      return this._readPredicate(token);\n    }\n  }\n\n  // ### `_readBlankNodeTail` reads the end of a blank node\n  _readBlankNodeTail(token) {\n    if (token.type !== ']')\n      return this._readBlankNodePunctuation(token);\n\n    // Store blank node quad\n    if (this._subject !== null)\n      this._emit(this._subject, this._predicate, this._object, this._graph);\n\n    // Restore the parent context containing this blank node\n    var empty = this._predicate === null;\n    this._restoreContext();\n    // If the blank node was the subject, continue reading the predicate\n    if (this._object === null)\n      // If the blank node was empty, it could be a named graph label\n      return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;\n    // If the blank node was the object, restore previous context and read punctuation\n    else\n      return this._getContextEndReader();\n  }\n\n  // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node\n  _readPredicateAfterBlank(token) {\n    switch (token.type) {\n    case '.':\n    case '}':\n      // No predicate is coming if the triple is terminated here\n      this._subject = null;\n      return this._readPunctuation(token);\n    default:\n      return this._readPredicate(token);\n    }\n  }\n\n  // ### `_readListItem` reads items from a list\n  _readListItem(token) {\n    var item = null,                      // The item of the list\n        list = null,                      // The list itself\n        previousList = this._subject,     // The previous list that contains this list\n        stack = this._contextStack,       // The stack of parent contexts\n        parent = stack[stack.length - 1], // The parent containing the current list\n        next = this._readListItem;        // The next function to execute\n\n    switch (token.type) {\n    case '[':\n      // Stack the current list quad and start a new quad with a blank node as subject\n      this._saveContext('blank', this._graph,\n                        list = this._blankNode(), this.RDF_FIRST,\n                        this._subject = item = this._blankNode());\n      next = this._readBlankNodeHead;\n      break;\n    case '(':\n      // Stack the current list quad and start a new list\n      this._saveContext('list', this._graph,\n                        list = this._blankNode(), this.RDF_FIRST, this.RDF_NIL);\n      this._subject = null;\n      break;\n    case ')':\n      // Closing the list; restore the parent context\n      this._restoreContext();\n      // If this list is contained within a parent list, return the membership quad here.\n      // This will be `<parent list element> rdf:first <this list>.`.\n      if (stack.length !== 0 && stack[stack.length - 1].type === 'list')\n        this._emit(this._subject, this._predicate, this._object, this._graph);\n      // Was this list the parent's subject?\n      if (this._predicate === null) {\n        // The next token is the predicate\n        next = this._readPredicate;\n        // No list tail if this was an empty list\n        if (this._subject === this.RDF_NIL)\n          return next;\n      }\n      // The list was in the parent context's object\n      else {\n        next = this._getContextEndReader();\n        // No list tail if this was an empty list\n        if (this._object === this.RDF_NIL)\n          return next;\n      }\n      // Close the list by making the head nil\n      list = this.RDF_NIL;\n      break;\n    case 'literal':\n      // Regular literal, can still get a datatype or language\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        next = this._readListItemDataTypeOrLang;\n      }\n      // Pre-datatyped string literal (prefix stores the datatype)\n      else {\n        item = this._literal(token.value, this._namedNode(token.prefix));\n        next = this._getContextEndReader();\n      }\n      break;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph, this._subject, this._predicate,\n                        this._graph = this._blankNode());\n      return this._readSubject;\n    default:\n      if ((item = this._readEntity(token)) === undefined)\n        return;\n    }\n\n     // Create a new blank node if no item head was assigned yet\n    if (list === null)\n      this._subject = list = this._blankNode();\n\n    // Is this the first element of the list?\n    if (previousList === null) {\n      // This list is either the subject or the object of its parent\n      if (parent.predicate === null)\n        parent.subject = list;\n      else\n        parent.object = list;\n    }\n    else {\n      // Continue the previous list with the current list\n      this._emit(previousList, this.RDF_REST, list, this._graph);\n    }\n    // If an item was read, add it to the list\n    if (item !== null) {\n      // In N3 mode, the item might be a path\n      if (this._n3Mode && (token.type === 'IRI' || token.type === 'prefixed')) {\n        // Create a new context to add the item's path\n        this._saveContext('item', this._graph, list, this.RDF_FIRST, item);\n        this._subject = item, this._predicate = null;\n        // _readPath will restore the context and output the item\n        return this._getPathReader(this._readListItem);\n      }\n      // Output the item\n      this._emit(list, this.RDF_FIRST, item, this._graph);\n    }\n    return next;\n  }\n\n  // ### `_readDataTypeOrLang` reads an _optional_ datatype or language\n  _readDataTypeOrLang(token) {\n    return this._completeObjectLiteral(token, false);\n  }\n\n\n  // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list\n  _readListItemDataTypeOrLang(token) {\n    return this._completeObjectLiteral(token, true);\n  }\n\n  // ### `_completeLiteral` completes a literal with an optional datatype or language\n  _completeLiteral(token) {\n    // Create a simple string literal by default\n    let literal = this._literal(this._literalValue);\n\n    switch (token.type) {\n    // Create a datatyped literal\n    case 'type':\n    case 'typeIRI':\n      var datatype = this._readEntity(token);\n      if (datatype === undefined) return; // No datatype means an error occurred\n      literal = this._literal(this._literalValue, datatype);\n      token = null;\n      break;\n    // Create a language-tagged string\n    case 'langcode':\n      literal = this._literal(this._literalValue, token.value);\n      token = null;\n      break;\n    }\n\n    return { token, literal };\n  }\n\n  // Completes a literal in subject position\n  _completeSubjectLiteral(token) {\n    this._subject = this._completeLiteral(token).literal;\n    return this._readPredicateOrNamedGraph;\n  }\n\n  // Completes a literal in object position\n  _completeObjectLiteral(token, listItem) {\n    const completed = this._completeLiteral(token);\n    if (!completed)\n      return;\n    this._object = completed.literal;\n\n    // If this literal was part of a list, write the item\n    // (we could also check the context stack, but passing in a flag is faster)\n    if (listItem)\n      this._emit(this._subject, this.RDF_FIRST, this._object, this._graph);\n    // If the token was consumed, continue with the rest of the input\n    if (completed.token === null)\n      return this._getContextEndReader();\n    // Otherwise, consume the token now\n    else {\n      this._readCallback = this._getContextEndReader();\n      return this._readCallback(completed.token);\n    }\n  }\n\n  // ### `_readFormulaTail` reads the end of a formula\n  _readFormulaTail(token) {\n    if (token.type !== '}')\n      return this._readPunctuation(token);\n\n    // Store the last quad of the formula\n    if (this._subject !== null)\n      this._emit(this._subject, this._predicate, this._object, this._graph);\n\n    // Restore the parent context containing this formula\n    this._restoreContext();\n    // If the formula was the subject, continue reading the predicate.\n    // If the formula was the object, read punctuation.\n    return this._object === null ? this._readPredicate : this._getContextEndReader();\n  }\n\n  // ### `_readPunctuation` reads punctuation between quads or quad parts\n  _readPunctuation(token) {\n    var next, subject = this._subject, graph = this._graph,\n        inversePredicate = this._inversePredicate;\n    switch (token.type) {\n    // A closing brace ends a graph\n    case '}':\n      if (this._graph === null)\n        return this._error('Unexpected graph closing', token);\n      if (this._n3Mode)\n        return this._readFormulaTail(token);\n      this._graph = null;\n    // A dot just ends the statement, without sharing anything with the next\n    case '.':\n      this._subject = null;\n      next = this._contextStack.length ? this._readSubject : this._readInTopContext;\n      if (inversePredicate) this._inversePredicate = false;\n      break;\n    // Semicolon means the subject is shared; predicate and object are different\n    case ';':\n      next = this._readPredicate;\n      break;\n    // Comma means both the subject and predicate are shared; the object is different\n    case ',':\n      next = this._readObject;\n      break;\n    default:\n      // An entity means this is a quad (only allowed if not already inside a graph)\n      if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== undefined) {\n        next = this._readQuadPunctuation;\n        break;\n      }\n      return this._error('Expected punctuation to follow \"' + this._object.id + '\"', token);\n    }\n    // A quad has been completed now, so return it\n    if (subject !== null) {\n      var predicate = this._predicate, object = this._object;\n      if (!inversePredicate)\n        this._emit(subject, predicate, object,  graph);\n      else\n        this._emit(object,  predicate, subject, graph);\n    }\n    return next;\n  }\n\n    // ### `_readBlankNodePunctuation` reads punctuation in a blank node\n  _readBlankNodePunctuation(token) {\n    var next;\n    switch (token.type) {\n    // Semicolon means the subject is shared; predicate and object are different\n    case ';':\n      next = this._readPredicate;\n      break;\n    // Comma means both the subject and predicate are shared; the object is different\n    case ',':\n      next = this._readObject;\n      break;\n    default:\n      return this._error('Expected punctuation to follow \"' + this._object.id + '\"', token);\n    }\n    // A quad has been completed now, so return it\n    this._emit(this._subject, this._predicate, this._object, this._graph);\n    return next;\n  }\n\n  // ### `_readQuadPunctuation` reads punctuation after a quad\n  _readQuadPunctuation(token) {\n    if (token.type !== '.')\n      return this._error('Expected dot to follow quad', token);\n    return this._readInTopContext;\n  }\n\n  // ### `_readPrefix` reads the prefix of a prefix declaration\n  _readPrefix(token) {\n    if (token.type !== 'prefix')\n      return this._error('Expected prefix to follow @prefix', token);\n    this._prefix = token.value;\n    return this._readPrefixIRI;\n  }\n\n  // ### `_readPrefixIRI` reads the IRI of a prefix declaration\n  _readPrefixIRI(token) {\n    if (token.type !== 'IRI')\n      return this._error('Expected IRI to follow prefix \"' + this._prefix + ':\"', token);\n    var prefixNode = this._readEntity(token);\n    this._prefixes[this._prefix] = prefixNode.value;\n    this._prefixCallback(this._prefix, prefixNode);\n    return this._readDeclarationPunctuation;\n  }\n\n  // ### `_readBaseIRI` reads the IRI of a base declaration\n  _readBaseIRI(token) {\n    var iri = token.type === 'IRI' && this._resolveIRI(token.value);\n    if (!iri)\n      return this._error('Expected valid IRI to follow base declaration', token);\n    this._setBase(iri);\n    return this._readDeclarationPunctuation;\n  }\n\n  // ### `_readNamedGraphLabel` reads the label of a named graph\n  _readNamedGraphLabel(token) {\n    switch (token.type) {\n    case 'IRI':\n    case 'blank':\n    case 'prefixed':\n      return this._readSubject(token), this._readGraph;\n    case '[':\n      return this._readNamedGraphBlankLabel;\n    default:\n      return this._error('Invalid graph label', token);\n    }\n  }\n\n  // ### `_readNamedGraphLabel` reads a blank node label of a named graph\n  _readNamedGraphBlankLabel(token) {\n    if (token.type !== ']')\n      return this._error('Invalid graph label', token);\n    this._subject = this._blankNode();\n    return this._readGraph;\n  }\n\n  // ### `_readDeclarationPunctuation` reads the punctuation of a declaration\n  _readDeclarationPunctuation(token) {\n    // SPARQL-style declarations don't have punctuation\n    if (this._sparqlStyle) {\n      this._sparqlStyle = false;\n      return this._readInTopContext(token);\n    }\n\n    if (token.type !== '.')\n      return this._error('Expected declaration to end with a dot', token);\n    return this._readInTopContext;\n  }\n\n  // Reads a list of quantified symbols from a @forSome or @forAll statement\n  _readQuantifierList(token) {\n    var entity;\n    switch (token.type) {\n    case 'IRI':\n    case 'prefixed':\n      if ((entity = this._readEntity(token, true)) !== undefined)\n        break;\n    default:\n      return this._error('Unexpected ' + token.type, token);\n    }\n    // Without explicit quantifiers, map entities to a quantified entity\n    if (!this._explicitQuantifiers)\n      this._quantified[entity.id] = this._quantifier(this._blankNode().value);\n    // With explicit quantifiers, output the reified quantifier\n    else {\n      // If this is the first item, start a new quantifier list\n      if (this._subject === null)\n        this._emit(this._graph || this.DEFAULTGRAPH, this._predicate,\n                   this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);\n      // Otherwise, continue the previous list\n      else\n        this._emit(this._subject, this.RDF_REST,\n                   this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);\n      // Output the list item\n      this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);\n    }\n    return this._readQuantifierPunctuation;\n  }\n\n  // Reads punctuation from a @forSome or @forAll statement\n  _readQuantifierPunctuation(token) {\n    // Read more quantifiers\n    if (token.type === ',')\n      return this._readQuantifierList;\n    // End of the quantifier list\n    else {\n      // With explicit quantifiers, close the quantifier list\n      if (this._explicitQuantifiers) {\n        this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);\n        this._subject = null;\n      }\n      // Read a dot\n      this._readCallback = this._getContextEndReader();\n      return this._readCallback(token);\n    }\n  }\n\n  // ### `_getPathReader` reads a potential path and then resumes with the given function\n  _getPathReader(afterPath) {\n    this._afterPath = afterPath;\n    return this._readPath;\n  }\n\n  // ### `_readPath` reads a potential path\n  _readPath(token) {\n    switch (token.type) {\n    // Forward path\n    case '!': return this._readForwardPath;\n    // Backward path\n    case '^': return this._readBackwardPath;\n    // Not a path; resume reading where we left off\n    default:\n      var stack = this._contextStack, parent = stack.length && stack[stack.length - 1];\n      // If we were reading a list item, we still need to output it\n      if (parent && parent.type === 'item') {\n        // The list item is the remaining subejct after reading the path\n        var item = this._subject;\n        // Switch back to the context of the list\n        this._restoreContext();\n        // Output the list item\n        this._emit(this._subject, this.RDF_FIRST, item, this._graph);\n      }\n      return this._afterPath(token);\n    }\n  }\n\n  // ### `_readForwardPath` reads a '!' path\n  _readForwardPath(token) {\n    var subject, predicate, object = this._blankNode();\n    // The next token is the predicate\n    if ((predicate = this._readEntity(token)) === undefined)\n      return;\n    // If we were reading a subject, replace the subject by the path's object\n    if (this._predicate === null)\n      subject = this._subject, this._subject = object;\n    // If we were reading an object, replace the subject by the path's object\n    else\n      subject = this._object,  this._object  = object;\n    // Emit the path's current quad and read its next section\n    this._emit(subject, predicate, object, this._graph);\n    return this._readPath;\n  }\n\n  // ### `_readBackwardPath` reads a '^' path\n  _readBackwardPath(token) {\n    var subject = this._blankNode(), predicate, object;\n    // The next token is the predicate\n    if ((predicate = this._readEntity(token)) === undefined)\n      return;\n    // If we were reading a subject, replace the subject by the path's subject\n    if (this._predicate === null)\n      object = this._subject, this._subject = subject;\n    // If we were reading an object, replace the subject by the path's subject\n    else\n      object = this._object,  this._object  = subject;\n    // Emit the path's current quad and read its next section\n    this._emit(subject, predicate, object, this._graph);\n    return this._readPath;\n  }\n\n  // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF* quad or the end of a nested RDF* triple\n  _readRDFStarTailOrGraph(token) {\n    if (token.type !== '>>') {\n      // An entity means this is a quad (only allowed if not already inside a graph)\n      if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== undefined)\n        return this._readRDFStarTail;\n      return this._error('Expected >> to follow \"' + this._object.id + '\"', token);\n    }\n    return this._readRDFStarTail(token);\n  }\n\n  // ### `_readRDFStarTail` reads the end of a nested RDF* triple\n  _readRDFStarTail(token) {\n    if (token.type !== '>>')\n      return this._error(`Expected >> but got ${token.type}`, token);\n    // Read the quad and restore the previous context\n    const quad = this._quad(this._subject, this._predicate, this._object,\n      this._graph || this.DEFAULTGRAPH);\n    this._restoreContext();\n    // If the triple was the subject, continue by reading the predicate.\n    if (this._subject === null) {\n      this._subject = quad;\n      return this._readPredicate;\n    }\n    // If the triple was the object, read context end.\n    else {\n      this._object = quad;\n      return this._getContextEndReader();\n    }\n  }\n\n  // ### `_getContextEndReader` gets the next reader function at the end of a context\n  _getContextEndReader() {\n    var contextStack = this._contextStack;\n    if (!contextStack.length)\n      return this._readPunctuation;\n\n    switch (contextStack[contextStack.length - 1].type) {\n    case 'blank':\n      return this._readBlankNodeTail;\n    case 'list':\n      return this._readListItem;\n    case 'formula':\n      return this._readFormulaTail;\n    case '<<':\n      return this._readRDFStarTailOrGraph;\n    }\n  }\n\n  // ### `_emit` sends a quad through the callback\n  _emit(subject, predicate, object, graph) {\n    this._callback(null, this._quad(subject, predicate, object, graph || this.DEFAULTGRAPH));\n  }\n\n  // ### `_error` emits an error message through the callback\n  _error(message, token) {\n    var err = new Error(message + ' on line ' + token.line + '.');\n    err.context = {\n      token: token,\n      line: token.line,\n      previousToken: this._lexer.previousToken,\n    };\n    this._callback(err);\n    this._callback = noop;\n  }\n\n  // ### `_resolveIRI` resolves an IRI against the base path\n  _resolveIRI(iri) {\n    return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);\n  }\n\n  // ### `_resolveRelativeIRI` resolves an IRI against the base path,\n  // assuming that a base path has been set and that the IRI is indeed relative\n  _resolveRelativeIRI(iri) {\n    // An empty relative IRI indicates the base IRI\n    if (!iri.length)\n      return this._base;\n    // Decide resolving strategy based in the first character\n    switch (iri[0]) {\n    // Resolve relative fragment IRIs against the base IRI\n    case '#': return this._base + iri;\n    // Resolve relative query string IRIs by replacing the query string\n    case '?': return this._base.replace(/(?:\\?.*)?$/, iri);\n    // Resolve root-relative IRIs at the root of the base IRI\n    case '/':\n      // Resolve scheme-relative IRIs to the scheme\n      return (iri[1] === '/' ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);\n    // Resolve all other IRIs at the base IRI's path\n    default:\n      // Relative IRIs cannot contain a colon in the first path segment\n      return (/^[^/:]*:/.test(iri)) ? null : this._removeDotSegments(this._basePath + iri);\n    }\n  }\n\n  // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986\n  _removeDotSegments(iri) {\n    // Don't modify the IRI if it does not contain any dot segments\n    if (!/(^|\\/)\\.\\.?($|[/#?])/.test(iri))\n      return iri;\n\n    // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n    var result = '', length = iri.length, i = -1, pathStart = -1, segmentStart = 0, next = '/';\n\n    while (i < length) {\n      switch (next) {\n      // The path starts with the first slash after the authority\n      case ':':\n        if (pathStart < 0) {\n          // Skip two slashes before the authority\n          if (iri[++i] === '/' && iri[++i] === '/')\n            // Skip to slash after the authority\n            while ((pathStart = i + 1) < length && iri[pathStart] !== '/')\n              i = pathStart;\n        }\n        break;\n      // Don't modify a query string or fragment\n      case '?':\n      case '#':\n        i = length;\n        break;\n      // Handle '/.' or '/..' path segments\n      case '/':\n        if (iri[i + 1] === '.') {\n          next = iri[++i + 1];\n          switch (next) {\n          // Remove a '/.' segment\n          case '/':\n            result += iri.substring(segmentStart, i - 1);\n            segmentStart = i + 1;\n            break;\n          // Remove a trailing '/.' segment\n          case undefined:\n          case '?':\n          case '#':\n            return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n          // Remove a '/..' segment\n          case '.':\n            next = iri[++i + 1];\n            if (next === undefined || next === '/' || next === '?' || next === '#') {\n              result += iri.substring(segmentStart, i - 2);\n              // Try to remove the parent path from result\n              if ((segmentStart = result.lastIndexOf('/')) >= pathStart)\n                result = result.substr(0, segmentStart);\n              // Remove a trailing '/..' segment\n              if (next !== '/')\n                return result + '/' + iri.substr(i + 1);\n              segmentStart = i + 1;\n            }\n          }\n        }\n      }\n      next = iri[++i];\n    }\n    return result + iri.substring(segmentStart);\n  }\n\n  // ## Public methods\n\n  // ### `parse` parses the N3 input and emits each parsed quad through the callback\n  parse(input, quadCallback, prefixCallback) {\n    var self = this;\n    // The read callback is the next function to be executed when a token arrives.\n    // We start reading in the top context.\n    this._readCallback = this._readInTopContext;\n    this._sparqlStyle = false;\n    this._prefixes = Object.create(null);\n    this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2)\n                                             : 'b' + blankNodePrefix++ + '_';\n    this._prefixCallback = prefixCallback || noop;\n    this._inversePredicate = false;\n    this._quantified = Object.create(null);\n\n    // Parse synchronously if no quad callback is given\n    if (!quadCallback) {\n      var quads = [], error;\n      this._callback = function (e, t) { e ? (error = e) : t && quads.push(t); };\n      this._lexer.tokenize(input).every(function (token) {\n        return self._readCallback = self._readCallback(token);\n      });\n      if (error) throw error;\n      return quads;\n    }\n\n    // Parse asynchronously otherwise, executing the read callback when a token arrives\n    this._callback = quadCallback;\n    this._lexer.tokenize(input, function (error, token) {\n      if (error !== null)\n        self._callback(error), self._callback = noop;\n      else if (self._readCallback)\n        self._readCallback = self._readCallback(token);\n    });\n  }\n}\n\n// The empty function\nfunction noop() {}\n\n// Initializes the parser with the given data factory\nfunction initDataFactory(parser, factory) {\n  // Set factory methods\n  var namedNode = factory.namedNode;\n  parser._namedNode   = namedNode;\n  parser._blankNode   = factory.blankNode;\n  parser._literal     = factory.literal;\n  parser._variable    = factory.variable;\n  parser._quad        = factory.quad;\n  parser.DEFAULTGRAPH = factory.defaultGraph();\n\n  // Set common named nodes\n  parser.RDF_FIRST  = namedNode(namespaces.rdf.first);\n  parser.RDF_REST   = namedNode(namespaces.rdf.rest);\n  parser.RDF_NIL    = namedNode(namespaces.rdf.nil);\n  parser.N3_FORALL  = namedNode(namespaces.r.forAll);\n  parser.N3_FORSOME = namedNode(namespaces.r.forSome);\n  parser.ABBREVIATIONS = {\n    'a': namedNode(namespaces.rdf.type),\n    '=': namedNode(namespaces.owl.sameAs),\n    '>': namedNode(namespaces.log.implies),\n  };\n  parser.QUANTIFIERS_GRAPH = namedNode('urn:n3:quantifiers');\n}\ninitDataFactory(N3Parser.prototype, N3DataFactory);\n","/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\nlet promise\n\nmodule.exports = typeof queueMicrotask === 'function'\n  ? queueMicrotask\n  // reuse resolved promise, and allocate it lazily\n  : cb => (promise || (promise = Promise.resolve()))\n    .then(cb)\n    .catch(err => setTimeout(() => { throw err }, 0))\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","// N3.js implementations of the RDF/JS core data types\n// See https://github.com/rdfjs/representation-task-force/blob/master/interface-spec.md\n\nimport namespaces from './IRIs';\nimport { isDefaultGraph } from './N3Util';\nconst { rdf, xsd } = namespaces;\n\nlet DEFAULTGRAPH;\nlet _blankNodeCounter = 0;\n\nconst escapedLiteral = /^\"(.*\".*)(?=\"[^\"]*$)/;\nconst quadId = /^<<(\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) (\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) (\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) ?(\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+)?>>$/;\n\n// ## DataFactory singleton\nconst DataFactory = {\n  namedNode,\n  blankNode,\n  variable,\n  literal,\n  defaultGraph,\n  quad,\n  triple: quad,\n};\nexport default DataFactory;\n\n// ## Term constructor\nexport class Term {\n  constructor(id) {\n    this.id = id;\n  }\n\n  // ### The value of this term\n  get value() {\n    return this.id;\n  }\n\n  // ### Returns whether this object represents the same term as the other\n  equals(other) {\n    // If both terms were created by this library,\n    // equality can be computed through ids\n    if (other instanceof Term)\n      return this.id === other.id;\n    // Otherwise, compare term type and value\n    return !!other && this.termType === other.termType &&\n                      this.value    === other.value;\n  }\n\n  // ### Returns a plain object representation of this term\n  toJSON() {\n    return {\n      termType: this.termType,\n      value:    this.value,\n    };\n  }\n}\n\n\n// ## NamedNode constructor\nexport class NamedNode extends Term {\n  // ### The term type of this term\n  get termType() {\n    return 'NamedNode';\n  }\n}\n\n// ## Literal constructor\nexport class Literal extends Term {\n  // ### The term type of this term\n  get termType() {\n    return 'Literal';\n  }\n\n  // ### The text value of this literal\n  get value() {\n    return this.id.substring(1, this.id.lastIndexOf('\"'));\n  }\n\n  // ### The language of this literal\n  get language() {\n    // Find the last quotation mark (e.g., '\"abc\"@en-us')\n    var id = this.id, atPos = id.lastIndexOf('\"') + 1;\n    // If \"@\" it follows, return the remaining substring; empty otherwise\n    return atPos < id.length && id[atPos++] === '@' ? id.substr(atPos).toLowerCase() : '';\n  }\n\n  // ### The datatype IRI of this literal\n  get datatype() {\n    return new NamedNode(this.datatypeString);\n  }\n\n  // ### The datatype string of this literal\n  get datatypeString() {\n    // Find the last quotation mark (e.g., '\"abc\"^^http://ex.org/types#t')\n    var id = this.id, dtPos = id.lastIndexOf('\"') + 1, ch;\n    // If \"^\" it follows, return the remaining substring\n    return dtPos < id.length && (ch = id[dtPos]) === '^' ? id.substr(dtPos + 2) :\n           // If \"@\" follows, return rdf:langString; xsd:string otherwise\n           (ch !== '@' ? xsd.string : rdf.langString);\n  }\n\n  // ### Returns whether this object represents the same term as the other\n  equals(other) {\n    // If both literals were created by this library,\n    // equality can be computed through ids\n    if (other instanceof Literal)\n      return this.id === other.id;\n    // Otherwise, compare term type, value, language, and datatype\n    return !!other && !!other.datatype &&\n                      this.termType === other.termType &&\n                      this.value    === other.value    &&\n                      this.language === other.language &&\n                      this.datatype.value === other.datatype.value;\n  }\n\n  toJSON() {\n    return {\n      termType: this.termType,\n      value:    this.value,\n      language: this.language,\n      datatype: { termType: 'NamedNode', value: this.datatypeString },\n    };\n  }\n}\n\n// ## BlankNode constructor\nexport class BlankNode extends Term {\n  constructor(name) {\n    super('_:' + name);\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'BlankNode';\n  }\n\n  // ### The name of this blank node\n  get value() {\n    return this.id.substr(2);\n  }\n}\n\nexport class Variable extends Term {\n  constructor(name) {\n    super('?' + name);\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'Variable';\n  }\n\n  // ### The name of this variable\n  get value() {\n    return this.id.substr(1);\n  }\n}\n\n// ## DefaultGraph constructor\nexport class DefaultGraph extends Term {\n  constructor() {\n    super('');\n    return DEFAULTGRAPH || this;\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'DefaultGraph';\n  }\n\n  // ### Returns whether this object represents the same term as the other\n  equals(other) {\n    // If both terms were created by this library,\n    // equality can be computed through strict equality;\n    // otherwise, compare term types.\n    return (this === other) || (!!other && (this.termType === other.termType));\n  }\n}\n\n// ## DefaultGraph singleton\nDEFAULTGRAPH = new DefaultGraph();\n\n\n// ### Constructs a term from the given internal string ID\nexport function termFromId(id, factory) {\n  factory = factory || DataFactory;\n\n  // Falsy value or empty string indicate the default graph\n  if (!id)\n    return factory.defaultGraph();\n\n  // Identify the term type based on the first character\n  switch (id[0]) {\n  case '?':\n    return factory.variable(id.substr(1));\n  case '_':\n    return factory.blankNode(id.substr(2));\n  case '\"':\n    // Shortcut for internal literals\n    if (factory === DataFactory)\n      return new Literal(id);\n    // Literal without datatype or language\n    if (id[id.length - 1] === '\"')\n      return factory.literal(id.substr(1, id.length - 2));\n    // Literal with datatype or language\n    var endPos = id.lastIndexOf('\"', id.length - 1);\n    return factory.literal(id.substr(1, endPos - 1),\n            id[endPos + 1] === '@' ? id.substr(endPos + 2)\n                                   : factory.namedNode(id.substr(endPos + 3)));\n  case '<':\n    const components = quadId.exec(id);\n    return factory.quad(\n      termFromId(unescapeQuotes(components[1]), factory),\n      termFromId(unescapeQuotes(components[2]), factory),\n      termFromId(unescapeQuotes(components[3]), factory),\n      components[4] && termFromId(unescapeQuotes(components[4]), factory)\n    );\n  default:\n    return factory.namedNode(id);\n  }\n}\n\n// ### Constructs an internal string ID from the given term or ID string\nexport function termToId(term) {\n  if (typeof term === 'string')\n    return term;\n  if (term instanceof Term && term.termType !== 'Quad')\n    return term.id;\n  if (!term)\n    return DEFAULTGRAPH.id;\n\n  // Term instantiated with another library\n  switch (term.termType) {\n  case 'NamedNode':    return term.value;\n  case 'BlankNode':    return '_:' + term.value;\n  case 'Variable':     return '?' + term.value;\n  case 'DefaultGraph': return '';\n  case 'Literal':      return '\"' + term.value + '\"' +\n    (term.language ? '@' + term.language :\n      (term.datatype && term.datatype.value !== xsd.string ? '^^' + term.datatype.value : ''));\n  case 'Quad':\n    // To identify RDF* quad components, we escape quotes by doubling them.\n    // This avoids the overhead of backslash parsing of Turtle-like syntaxes.\n    return `<<${\n        escapeQuotes(termToId(term.subject))\n      } ${\n        escapeQuotes(termToId(term.predicate))\n      } ${\n        escapeQuotes(termToId(term.object))\n      }${\n        (isDefaultGraph(term.graph)) ? '' : ` ${termToId(term.graph)}`\n      }>>`;\n  default: throw new Error('Unexpected termType: ' + term.termType);\n  }\n}\n\n\n// ## Quad constructor\nexport class Quad extends Term {\n  constructor(subject, predicate, object, graph) {\n    super('');\n    this.subject   = subject;\n    this.predicate = predicate;\n    this.object    = object;\n    this.graph     = graph || DEFAULTGRAPH;\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'Quad';\n  }\n\n  // ### Returns a plain object representation of this quad\n  toJSON() {\n    return {\n      termType:  this.termType,\n      subject:   this.subject.toJSON(),\n      predicate: this.predicate.toJSON(),\n      object:    this.object.toJSON(),\n      graph:     this.graph.toJSON(),\n    };\n  }\n\n  // ### Returns whether this object represents the same quad as the other\n  equals(other) {\n    return !!other && this.subject.equals(other.subject)     &&\n                      this.predicate.equals(other.predicate) &&\n                      this.object.equals(other.object)       &&\n                      this.graph.equals(other.graph);\n  }\n}\nexport { Quad as Triple };\n\n// ### Escapes the quotes within the given literal\nexport function escapeQuotes(id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"/g, '\"\"')}`);\n}\n\n// ### Unescapes the quotes within the given literal\nexport function unescapeQuotes(id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"\"/g, '\"')}`);\n}\n\n// ### Creates an IRI\nfunction namedNode(iri) {\n  return new NamedNode(iri);\n}\n\n// ### Creates a blank node\nfunction blankNode(name) {\n  return new BlankNode(name || `n3-${_blankNodeCounter++}`);\n}\n\n// ### Creates a literal\nfunction literal(value, languageOrDataType) {\n  // Create a language-tagged string\n  if (typeof languageOrDataType === 'string')\n    return new Literal('\"' + value + '\"@' + languageOrDataType.toLowerCase());\n\n  // Automatically determine datatype for booleans and numbers\n  let datatype = languageOrDataType ? languageOrDataType.value : '';\n  if (datatype === '') {\n    // Convert a boolean\n    if (typeof value === 'boolean')\n      datatype = xsd.boolean;\n    // Convert an integer or double\n    else if (typeof value === 'number') {\n      if (Number.isFinite(value))\n        datatype = Number.isInteger(value) ? xsd.integer : xsd.double;\n      else {\n        datatype = xsd.double;\n        if (!Number.isNaN(value))\n          value = value > 0 ? 'INF' : '-INF';\n      }\n    }\n  }\n\n  // Create a datatyped literal\n  return (datatype === '' || datatype === xsd.string) ?\n    new Literal('\"' + value + '\"') :\n    new Literal('\"' + value + '\"^^' + datatype);\n}\n\n// ### Creates a variable\nfunction variable(name) {\n  return new Variable(name);\n}\n\n// ### Returns the default graph\nfunction defaultGraph() {\n  return DEFAULTGRAPH;\n}\n\n// ### Creates a quad\nfunction quad(subject, predicate, object, graph) {\n  return new Quad(subject, predicate, object, graph);\n}\n","// **N3Writer** writes N3 documents.\nimport namespaces from './IRIs';\nimport { default as N3DataFactory, Term } from './N3DataFactory';\nimport { isDefaultGraph } from './N3Util';\n\nconst DEFAULTGRAPH = N3DataFactory.defaultGraph();\n\nconst { rdf, xsd } = namespaces;\n\n// Characters in literals that require escaping\nvar escape    = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n    escapeAll = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n    escapedCharacters = {\n      '\\\\': '\\\\\\\\', '\"': '\\\\\"', '\\t': '\\\\t',\n      '\\n': '\\\\n', '\\r': '\\\\r', '\\b': '\\\\b', '\\f': '\\\\f',\n    };\n\n// ## Placeholder class to represent already pretty-printed terms\nclass SerializedTerm extends Term {\n  // Pretty-printed nodes are not equal to any other node\n  // (e.g., [] does not equal [])\n  equals() {\n    return false;\n  }\n}\n\n// ## Constructor\nexport default class N3Writer {\n  constructor(outputStream, options) {\n    // ### `_prefixRegex` matches a prefixed name or IRI that begins with one of the added prefixes\n    this._prefixRegex = /$0^/;\n\n    // Shift arguments if the first argument is not a stream\n    if (outputStream && typeof outputStream.write !== 'function')\n      options = outputStream, outputStream = null;\n    options = options || {};\n    this._lists = options.lists;\n\n    // If no output stream given, send the output as string through the end callback\n    if (!outputStream) {\n      var output = '';\n      this._outputStream = {\n        write(chunk, encoding, done) { output += chunk; done && done(); },\n        end:   function (done) { done && done(null, output); },\n      };\n      this._endStream = true;\n    }\n    else {\n      this._outputStream = outputStream;\n      this._endStream = options.end === undefined ? true : !!options.end;\n    }\n\n    // Initialize writer, depending on the format\n    this._subject = null;\n    if (!(/triple|quad/i).test(options.format)) {\n      this._graph = DEFAULTGRAPH;\n      this._prefixIRIs = Object.create(null);\n      options.prefixes && this.addPrefixes(options.prefixes);\n    }\n    else {\n      this._writeQuad = this._writeQuadLine;\n    }\n  }\n\n  // ## Private methods\n\n  // ### Whether the current graph is the default graph\n  get _inDefaultGraph() {\n    return DEFAULTGRAPH.equals(this._graph);\n  }\n\n  // ### `_write` writes the argument to the output stream\n  _write(string, callback) {\n    this._outputStream.write(string, 'utf8', callback);\n  }\n\n  // ### `_writeQuad` writes the quad to the output stream\n  _writeQuad(subject, predicate, object, graph, done) {\n    try {\n      // Write the graph's label if it has changed\n      if (!graph.equals(this._graph)) {\n        // Close the previous graph and start the new one\n        this._write((this._subject === null ? '' : (this._inDefaultGraph ? '.\\n' : '\\n}\\n')) +\n                    (DEFAULTGRAPH.equals(graph) ? '' : this._encodeIriOrBlank(graph) + ' {\\n'));\n        this._graph = graph;\n        this._subject = null;\n      }\n      // Don't repeat the subject if it's the same\n      if (subject.equals(this._subject)) {\n        // Don't repeat the predicate if it's the same\n        if (predicate.equals(this._predicate))\n          this._write(', ' + this._encodeObject(object), done);\n        // Same subject, different predicate\n        else\n          this._write(';\\n    ' +\n                      this._encodePredicate(this._predicate = predicate) + ' ' +\n                      this._encodeObject(object), done);\n      }\n      // Different subject; write the whole quad\n      else\n        this._write((this._subject === null ? '' : '.\\n') +\n                    this._encodeSubject(this._subject = subject) + ' ' +\n                    this._encodePredicate(this._predicate = predicate) + ' ' +\n                    this._encodeObject(object), done);\n    }\n    catch (error) { done && done(error); }\n  }\n\n  // ### `_writeQuadLine` writes the quad to the output stream as a single line\n  _writeQuadLine(subject, predicate, object, graph, done) {\n    // Write the quad without prefixes\n    delete this._prefixMatch;\n    this._write(this.quadToString(subject, predicate, object, graph), done);\n  }\n\n  // ### `quadToString` serializes a quad as a string\n  quadToString(subject, predicate, object, graph) {\n    return  this._encodeSubject(subject)   + ' ' +\n            this._encodeIriOrBlank(predicate) + ' ' +\n            this._encodeObject(object) +\n            (graph && graph.value ? ' ' + this._encodeIriOrBlank(graph) + ' .\\n' : ' .\\n');\n  }\n\n  // ### `quadsToString` serializes an array of quads as a string\n  quadsToString(quads) {\n    return quads.map(function (t) {\n      return this.quadToString(t.subject, t.predicate, t.object, t.graph);\n    }, this).join('');\n  }\n\n  // ### `_encodeSubject` represents a subject\n  _encodeSubject(entity) {\n    return entity.termType === 'Quad' ?\n      this._encodeQuad(entity) : this._encodeIriOrBlank(entity);\n  }\n\n  // ### `_encodeIriOrBlank` represents an IRI or blank node\n  _encodeIriOrBlank(entity) {\n    // A blank node or list is represented as-is\n    if (entity.termType !== 'NamedNode') {\n      // If it is a list head, pretty-print it\n      if (this._lists && (entity.value in this._lists))\n        entity = this.list(this._lists[entity.value]);\n      return 'id' in entity ? entity.id : '_:' + entity.value;\n    }\n    // Escape special characters\n    var iri = entity.value;\n    if (escape.test(iri))\n      iri = iri.replace(escapeAll, characterReplacer);\n    // Try to represent the IRI as prefixed name\n    var prefixMatch = this._prefixRegex.exec(iri);\n    return !prefixMatch ? '<' + iri + '>' :\n           (!prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2]);\n  }\n\n  // ### `_encodeLiteral` represents a literal\n  _encodeLiteral(literal) {\n    // Escape special characters\n    var value = literal.value;\n    if (escape.test(value))\n      value = value.replace(escapeAll, characterReplacer);\n    // Write the literal, possibly with type or language\n    if (literal.language)\n      return '\"' + value + '\"@' + literal.language;\n    else if (literal.datatype.value !== xsd.string)\n      return '\"' + value + '\"^^' + this._encodeIriOrBlank(literal.datatype);\n    else\n      return '\"' + value + '\"';\n  }\n\n  // ### `_encodePredicate` represents a predicate\n  _encodePredicate(predicate) {\n    return predicate.value === rdf.type ? 'a' : this._encodeIriOrBlank(predicate);\n  }\n\n  // ### `_encodeObject` represents an object\n  _encodeObject(object) {\n    switch (object.termType) {\n    case 'Quad':\n      return this._encodeQuad(object);\n    case 'Literal':\n      return this._encodeLiteral(object);\n    default:\n      return this._encodeIriOrBlank(object);\n    }\n  }\n\n  // ### `_encodeQuad` encodes an RDF* quad\n  _encodeQuad({ subject, predicate, object, graph }) {\n    return `<<${\n      this._encodeSubject(subject)} ${\n      this._encodePredicate(predicate)} ${\n      this._encodeObject(object)}${\n      isDefaultGraph(graph) ? '' : ` ${this._encodeIriOrBlank(graph)}`}>>`;\n  }\n\n  // ### `_blockedWrite` replaces `_write` after the writer has been closed\n  _blockedWrite() {\n    throw new Error('Cannot write because the writer has been closed.');\n  }\n\n  // ### `addQuad` adds the quad to the output stream\n  addQuad(subject, predicate, object, graph, done) {\n    // The quad was given as an object, so shift parameters\n    if (object === undefined)\n      this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate);\n    // The optional `graph` parameter was not provided\n    else if (typeof graph === 'function')\n      this._writeQuad(subject, predicate, object, DEFAULTGRAPH, graph);\n    // The `graph` parameter was provided\n    else\n      this._writeQuad(subject, predicate, object, graph || DEFAULTGRAPH, done);\n  }\n\n  // ### `addQuads` adds the quads to the output stream\n  addQuads(quads) {\n    for (var i = 0; i < quads.length; i++)\n      this.addQuad(quads[i]);\n  }\n\n  // ### `addPrefix` adds the prefix to the output stream\n  addPrefix(prefix, iri, done) {\n    var prefixes = {};\n    prefixes[prefix] = iri;\n    this.addPrefixes(prefixes, done);\n  }\n\n  // ### `addPrefixes` adds the prefixes to the output stream\n  addPrefixes(prefixes, done) {\n    var prefixIRIs = this._prefixIRIs, hasPrefixes = false;\n    for (var prefix in prefixes) {\n      var iri = prefixes[prefix];\n      if (typeof iri !== 'string')\n        iri = iri.value;\n      hasPrefixes = true;\n      // Finish a possible pending quad\n      if (this._subject !== null) {\n        this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n        this._subject = null, this._graph = '';\n      }\n      // Store and write the prefix\n      prefixIRIs[iri] = (prefix += ':');\n      this._write('@prefix ' + prefix + ' <' + iri + '>.\\n');\n    }\n    // Recreate the prefix matcher\n    if (hasPrefixes) {\n      var IRIlist = '', prefixList = '';\n      for (var prefixIRI in prefixIRIs) {\n        IRIlist += IRIlist ? '|' + prefixIRI : prefixIRI;\n        prefixList += (prefixList ? '|' : '') + prefixIRIs[prefixIRI];\n      }\n      IRIlist = IRIlist.replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n      this._prefixRegex = new RegExp('^(?:' + prefixList + ')[^\\/]*$|' +\n                                     '^(' + IRIlist + ')([a-zA-Z][\\\\-_a-zA-Z0-9]*)$');\n    }\n    // End a prefix block with a newline\n    this._write(hasPrefixes ? '\\n' : '', done);\n  }\n\n  // ### `blank` creates a blank node with the given content\n  blank(predicate, object) {\n    var children = predicate, child, length;\n    // Empty blank node\n    if (predicate === undefined)\n      children = [];\n    // Blank node passed as blank(Term(\"predicate\"), Term(\"object\"))\n    else if (predicate.termType)\n      children = [{ predicate: predicate, object: object }];\n    // Blank node passed as blank({ predicate: predicate, object: object })\n    else if (!('length' in predicate))\n      children = [predicate];\n\n    switch (length = children.length) {\n    // Generate an empty blank node\n    case 0:\n      return new SerializedTerm('[]');\n    // Generate a non-nested one-triple blank node\n    case 1:\n      child = children[0];\n      if (!(child.object instanceof SerializedTerm))\n        return new SerializedTerm('[ ' + this._encodePredicate(child.predicate) + ' ' +\n                                  this._encodeObject(child.object) + ' ]');\n    // Generate a multi-triple or nested blank node\n    default:\n      var contents = '[';\n      // Write all triples in order\n      for (var i = 0; i < length; i++) {\n        child = children[i];\n        // Write only the object is the predicate is the same as the previous\n        if (child.predicate.equals(predicate))\n          contents += ', ' + this._encodeObject(child.object);\n        // Otherwise, write the predicate and the object\n        else {\n          contents += (i ? ';\\n  ' : '\\n  ') +\n                      this._encodePredicate(child.predicate) + ' ' +\n                      this._encodeObject(child.object);\n          predicate = child.predicate;\n        }\n      }\n      return new SerializedTerm(contents + '\\n]');\n    }\n  }\n\n  // ### `list` creates a list node with the given content\n  list(elements) {\n    var length = elements && elements.length || 0, contents = new Array(length);\n    for (var i = 0; i < length; i++)\n      contents[i] = this._encodeObject(elements[i]);\n    return new SerializedTerm('(' + contents.join(' ') + ')');\n  }\n\n  // ### `end` signals the end of the output stream\n  end(done) {\n    // Finish a possible pending quad\n    if (this._subject !== null) {\n      this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n      this._subject = null;\n    }\n    // Disallow further writing\n    this._write = this._blockedWrite;\n\n    // Try to end the underlying stream, ensuring done is called exactly one time\n    var singleDone = done && function (error, result) { singleDone = null, done(error, result); };\n    if (this._endStream) {\n      try { return this._outputStream.end(singleDone); }\n      catch (error) { /* error closing stream */ }\n    }\n    singleDone && singleDone();\n  }\n}\n\n// Replaces a character by its escaped version\nfunction characterReplacer(character) {\n  // Replace a single character by its escaped version\n  var result = escapedCharacters[character];\n  if (result === undefined) {\n    // Replace a single character with its 4-bit unicode escape sequence\n    if (character.length === 1) {\n      result = character.charCodeAt(0).toString(16);\n      result = '\\\\u0000'.substr(0, 6 - result.length) + result;\n    }\n    // Replace a surrogate pair with its 8-bit unicode escape sequence\n    else {\n      result = ((character.charCodeAt(0) - 0xD800) * 0x400 +\n                 character.charCodeAt(1) + 0x2400).toString(16);\n      result = '\\\\U00000000'.substr(0, 10 - result.length) + result;\n    }\n  }\n  return result;\n}\n","// **N3Util** provides N3 utility functions.\n\nimport N3DataFactory from './N3DataFactory';\n\n// Tests whether the given term represents an IRI\nexport function isNamedNode(term) {\n  return !!term && term.termType === 'NamedNode';\n}\n\n// Tests whether the given term represents a blank node\nexport function isBlankNode(term) {\n  return !!term && term.termType === 'BlankNode';\n}\n\n// Tests whether the given term represents a literal\nexport function isLiteral(term) {\n  return !!term && term.termType === 'Literal';\n}\n\n// Tests whether the given term represents a variable\nexport function isVariable(term) {\n  return !!term && term.termType === 'Variable';\n}\n\n// Tests whether the given term represents the default graph\nexport function isDefaultGraph(term) {\n  return !!term && term.termType === 'DefaultGraph';\n}\n\n// Tests whether the given quad is in the default graph\nexport function inDefaultGraph(quad) {\n  return isDefaultGraph(quad.graph);\n}\n\n// Creates a function that prepends the given IRI to a local name\nexport function prefix(iri, factory) {\n  return prefixes({ '': iri }, factory)('');\n}\n\n// Creates a function that allows registering and expanding prefixes\nexport function prefixes(defaultPrefixes, factory) {\n  // Add all of the default prefixes\n  var prefixes = Object.create(null);\n  for (var prefix in defaultPrefixes)\n    processPrefix(prefix, defaultPrefixes[prefix]);\n  // Set the default factory if none was specified\n  factory = factory || N3DataFactory;\n\n  // Registers a new prefix (if an IRI was specified)\n  // or retrieves a function that expands an existing prefix (if no IRI was specified)\n  function processPrefix(prefix, iri) {\n    // Create a new prefix if an IRI is specified or the prefix doesn't exist\n    if (typeof iri === 'string') {\n      // Create a function that expands the prefix\n      var cache = Object.create(null);\n      prefixes[prefix] = function (local) {\n        return cache[local] || (cache[local] = factory.namedNode(iri + local));\n      };\n    }\n    else if (!(prefix in prefixes)) {\n      throw new Error('Unknown prefix: ' + prefix);\n    }\n    return prefixes[prefix];\n  }\n  return processPrefix;\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","'use strict'\n\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g\nvar DELIMITER_PATTERN = /[;,\"]/\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/\n\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2,\n}\n\nfunction trim( value ) {\n  return value.replace( WS_TRIM_PATTERN, '' )\n}\n\nfunction hasWhitespace( value ) {\n  return WS_CHAR_PATTERN.test( value )\n}\n\nfunction skipWhitespace( value, offset ) {\n  while( hasWhitespace( value[offset] ) ) {\n    offset++\n  }\n  return offset\n}\n\nfunction needsQuotes( value ) {\n  return WS_DELIMITER_PATTERN.test( value )\n}\n\nclass Link {\n\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  constructor( value ) {\n\n    /** @type {Array} URI references */\n    this.refs = []\n\n    if( value ) {\n      this.parse( value )\n    }\n\n  }\n\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  rel( value ) {\n\n    var links = []\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ].rel === value ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /**\n   * Get refs where given attribute has a given value\n   * @param {String} attr\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  get( attr, value ) {\n\n    attr = attr.toLowerCase()\n\n    var links = []\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ][ attr ] === value ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  set( link ) {\n    this.refs.push( link )\n    return this\n  }\n\n  has( attr, value ) {\n\n    attr = attr.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ][ attr ] === value ) {\n        return true\n      }\n    }\n\n    return false\n\n  }\n\n  parse( value, offset ) {\n\n    offset = offset || 0\n    value = offset ? value.slice( offset ) : value\n\n    // Trim & unfold folded lines\n    value = trim( value ).replace( WS_FOLD_PATTERN, '' )\n\n    var state = STATE.IDLE\n    var length = value.length\n    var offset = 0\n    var ref = null\n\n    while( offset < length ) {\n      if( state === STATE.IDLE ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === '<' ) {\n          var end = value.indexOf( '>', offset )\n          if( end === -1 ) throw new Error( 'Expected end of URI delimiter at offset ' + offset )\n          ref = { uri: value.slice( offset + 1, end ) }\n          this.refs.push( ref )\n          offset = end\n          state = STATE.URI\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n        offset++\n      } else if( state === STATE.URI ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === ';' ) {\n          state = STATE.ATTR\n          offset++\n        } else if( value[offset] === ',' ) {\n          state = STATE.IDLE\n          offset++\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n      } else if( state === STATE.ATTR ) {\n        if( value[offset] ===';' || hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        }\n        var end = value.indexOf( '=', offset )\n        if( end === -1 ) throw new Error( 'Expected attribute delimiter at offset ' + offset )\n        var attr = trim( value.slice( offset, end ) ).toLowerCase()\n        var attrValue = ''\n        offset = end + 1\n        offset = skipWhitespace( value, offset )\n        if( value[offset] === '\"' ) {\n          offset++\n          while( offset < length ) {\n            if( value[offset] === '\"' ) {\n              offset++; break\n            }\n            if( value[offset] === '\\\\' ) {\n              offset++\n            }\n            attrValue += value[offset]\n            offset++\n          }\n        } else {\n          var end = offset + 1\n          while( !DELIMITER_PATTERN.test( value[end] ) && end < length ) {\n            end++\n          }\n          attrValue = value.slice( offset, end )\n          offset = end\n        }\n        if( ref[ attr ] && Link.isSingleOccurenceAttr( attr ) ) {\n          // Ignore multiples of attributes which may only appear once\n        } else if( attr[ attr.length - 1 ] === '*' ) {\n          ref[ attr ] = Link.parseExtendedValue( attrValue )\n        } else {\n          attrValue = attr === 'rel' || attr === 'type' ?\n            attrValue.toLowerCase() : attrValue\n          if( ref[ attr ] != null ) {\n            if( Array.isArray( ref[ attr ] ) ) {\n              ref[ attr ].push( attrValue )\n            } else {\n              ref[ attr ] = [ ref[ attr ], attrValue ]\n            }\n          } else {\n            ref[ attr ] = attrValue\n          }\n        }\n        switch( value[offset] ) {\n          case ',': state = STATE.IDLE; break\n          case ';': state = STATE.ATTR; break\n        }\n        offset++\n      } else {\n        throw new Error( 'Unknown parser state \"' + state + '\"' )\n      }\n    }\n\n    ref = null\n\n    return this\n\n  }\n\n  toString() {\n\n    var refs = []\n    var link = ''\n    var ref = null\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      ref = this.refs[i]\n      link = Object.keys( this.refs[i] ).reduce( function( link, attr ) {\n        if( attr === 'uri' ) return link\n        return link + '; ' + Link.formatAttribute( attr, ref[ attr ] )\n      }, '<' + ref.uri + '>' )\n      refs.push( link )\n    }\n\n    return refs.join( ', ' )\n\n  }\n\n}\n\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\nLink.isCompatibleEncoding = function( value ) {\n  return COMPATIBLE_ENCODING_PATTERN.test( value )\n}\n\nLink.parse = function( value, offset ) {\n  return new Link().parse( value, offset )\n}\n\nLink.isSingleOccurenceAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' ||\n    attr === 'title' || attr === 'title*'\n}\n\nLink.isTokenAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor'\n}\n\nLink.escapeQuotes = function( value ) {\n  return value.replace( /\"/g, '\\\\\"' )\n}\n\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\nLink.parseExtendedValue = function( value ) {\n  var parts = /([^']+)?(?:'([^']+)')?(.+)/.exec( value )\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding( parts[1] ) ?\n      null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding( parts[1] ) ?\n      decodeURIComponent( parts[3] ) : parts[3]\n  }\n}\n\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\nLink.formatExtendedAttribute = function( attr, data ) {\n\n  var encoding = ( data.encoding || 'utf-8' ).toUpperCase()\n  var language = data.language || 'en'\n\n  var encodedValue = ''\n\n  if( Buffer.isBuffer( data.value ) && Link.isCompatibleEncoding( encoding ) ) {\n    encodedValue = data.value.toString( encoding )\n  } else if( Buffer.isBuffer( data.value ) ) {\n    encodedValue = data.value.toString( 'hex' )\n      .replace( /[0-9a-f]{2}/gi, '%$1' )\n  } else {\n    encodedValue = encodeURIComponent( data.value )\n  }\n\n  return attr + '=' + encoding + '\\'' +\n    language + '\\'' + encodedValue\n\n}\n\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\nLink.formatAttribute = function( attr, value ) {\n\n  if( Array.isArray( value ) ) {\n    return value.map(( item ) => {\n      return Link.formatAttribute( attr, item )\n    }).join( '; ' )\n  }\n\n  if( attr[ attr.length - 1 ] === '*' || typeof value !== 'string' ) {\n    return Link.formatExtendedAttribute( attr, value )\n  }\n\n  if( Link.isTokenAttr( attr ) ) {\n    value = needsQuotes( value ) ?\n      '\"' + Link.escapeQuotes( value ) + '\"' :\n      Link.escapeQuotes( value )\n  } else if( needsQuotes( value ) ) {\n    value = encodeURIComponent( value )\n    // We don't need to escape <SP> <,> <;> within quotes\n    value = value\n      .replace( /%20/g, ' ' )\n      .replace( /%2C/g, ',' )\n      .replace( /%3B/g, ';' )\n\n    value = '\"' + value + '\"'\n  }\n\n  return attr + '=' + value\n\n}\n\nmodule.exports = Link\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","// **N3Lexer** tokenizes N3 documents.\nimport namespaces from './IRIs';\nimport queueMicrotask from 'queue-microtask';\n\nconst { xsd } = namespaces;\n\n// Regular expression and replacement string to escape N3 strings\nvar escapeSequence = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\([^])/g;\nvar escapeReplacements = {\n  '\\\\': '\\\\', \"'\": \"'\", '\"': '\"',\n  'n': '\\n', 'r': '\\r', 't': '\\t', 'f': '\\f', 'b': '\\b',\n  '_': '_', '~': '~', '.': '.', '-': '-', '!': '!', '$': '$', '&': '&',\n  '(': '(', ')': ')', '*': '*', '+': '+', ',': ',', ';': ';', '=': '=',\n  '/': '/', '?': '?', '#': '#', '@': '@', '%': '%',\n};\nvar illegalIriChars = /[\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]/;\n\nvar lineModeRegExps = {\n  _iri: true,\n  _unescapedIri: true,\n  _simpleQuotedString: true,\n  _langcode: true,\n  _blank: true,\n  _newline: true,\n  _comment: true,\n  _whitespace: true,\n  _endOfFile: true,\n};\nvar invalidRegExp = /$0^/;\n\n// ## Constructor\nexport default class N3Lexer {\n  constructor(options) {\n    // ## Regular expressions\n    // It's slightly faster to have these as properties than as in-scope variables\n    this._iri = /^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/; // IRI with escape sequences; needs sanity check after unescaping\n    this._unescapedIri = /^<([^\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/; // IRI without escape sequences; no unescaping\n    this._simpleQuotedString = /^\"([^\"\\\\\\r\\n]*)\"(?=[^\"])/; // string without escape sequences\n    this._simpleApostropheString = /^'([^'\\\\\\r\\n]*)'(?=[^'])/;\n    this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\\-])/i;\n    this._prefix = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:(?=[#\\s<])/;\n    this._prefixed = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:((?:(?:[0-:A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])(?:(?:[\\.\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])*(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~]))?)?)(?:[ \\t]+|(?=\\.?[,;!\\^\\s#()\\[\\]\\{\\}\"'<>]))/;\n    this._variable = /^\\?(?:(?:[A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?=[.,;!\\^\\s#()\\[\\]\\{\\}\"'<])/;\n    this._blank = /^_:((?:[0-9A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?:[ \\t]+|(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>]))/;\n    this._number = /^[\\-+]?(?:(\\d+\\.\\d*|\\.?\\d+)[eE][\\-+]?|\\d*(\\.)?)\\d+(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<])/;\n    this._boolean = /^(?:true|false)(?=[.,;\\s#()\\[\\]\\{\\}\"'<])/;\n    this._keyword = /^@[a-z]+(?=[\\s#<:])/i;\n    this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\\s#<])/i;\n    this._shortPredicates = /^a(?=[\\s()\\[\\]\\{\\}\"'<])/;\n    this._newline = /^[ \\t]*(?:#[^\\n\\r]*)?(?:\\r\\n|\\n|\\r)[ \\t]*/;\n    this._comment = /#([^\\n\\r]*)/;\n    this._whitespace = /^[ \\t]+/;\n    this._endOfFile = /^(?:#[^\\n\\r]*)?$/;\n    options = options || {};\n\n    // In line mode (N-Triples or N-Quads), only simple features may be parsed\n    if (this._lineMode = !!options.lineMode) {\n      this._n3Mode = false;\n      // Don't tokenize special literals\n      for (var key in this) {\n        if (!(key in lineModeRegExps) && this[key] instanceof RegExp)\n          this[key] = invalidRegExp;\n      }\n    }\n    // When not in line mode, enable N3 functionality by default\n    else {\n      this._n3Mode = options.n3 !== false;\n    }\n    // Don't output comment tokens by default\n    this._comments = !!options.comments;\n    // Cache the last tested closing position of long literals\n    this._literalClosingPos = 0;\n  }\n\n  // ## Private methods\n\n  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback\n  _tokenizeToEnd(callback, inputFinished) {\n    // Continue parsing as far as possible; the loop will return eventually\n    var input = this._input, outputComments = this._comments;\n    while (true) {\n      // Count and skip whitespace lines\n      var whiteSpaceMatch, comment;\n      while (whiteSpaceMatch = this._newline.exec(input)) {\n        // Try to find a comment\n        if (outputComments && (comment = this._comment.exec(whiteSpaceMatch[0])))\n          callback(null, { line: this._line, type: 'comment', value: comment[1], prefix: '' });\n        // Advance the input\n        input = input.substr(whiteSpaceMatch[0].length, input.length);\n        this._line++;\n      }\n      // Skip whitespace on current line\n      if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input)))\n        input = input.substr(whiteSpaceMatch[0].length, input.length);\n\n      // Stop for now if we're at the end\n      if (this._endOfFile.test(input)) {\n        // If the input is finished, emit EOF\n        if (inputFinished) {\n          // Try to find a final comment\n          if (outputComments && (comment = this._comment.exec(input)))\n            callback(null, { line: this._line, type: 'comment', value: comment[1], prefix: '' });\n          callback(input = null, { line: this._line, type: 'eof', value: '', prefix: '' });\n        }\n        return this._input = input;\n      }\n\n      // Look for specific token types based on the first character\n      var line = this._line, type = '', value = '', prefix = '',\n          firstChar = input[0], match = null, matchLength = 0, inconclusive = false;\n      switch (firstChar) {\n      case '^':\n        // We need at least 3 tokens lookahead to distinguish ^^<IRI> and ^^pre:fixed\n        if (input.length < 3)\n          break;\n        // Try to match a type\n        else if (input[1] === '^') {\n          this._previousMarker = '^^';\n          // Move to type IRI or prefixed name\n          input = input.substr(2);\n          if (input[0] !== '<') {\n            inconclusive = true;\n            break;\n          }\n        }\n        // If no type, it must be a path expression\n        else {\n          if (this._n3Mode) {\n            matchLength = 1;\n            type = '^';\n          }\n          break;\n        }\n        // Fall through in case the type is an IRI\n      case '<':\n        // Try to find a full IRI without escape sequences\n        if (match = this._unescapedIri.exec(input))\n          type = 'IRI', value = match[1];\n        // Try to find a full IRI with escape sequences\n        else if (match = this._iri.exec(input)) {\n          value = this._unescape(match[1]);\n          if (value === null || illegalIriChars.test(value))\n            return reportSyntaxError(this);\n          type = 'IRI';\n        }\n        // Try to find a nested triple\n        else if (input.length > 1 && input[1] === '<')\n          type = '<<', matchLength = 2;\n        // Try to find a backwards implication arrow\n        else if (this._n3Mode && input.length > 1 && input[1] === '=')\n          type = 'inverse', matchLength = 2, value = '>';\n        break;\n\n      case '>':\n        if (input.length > 1 && input[1] === '>')\n          type = '>>', matchLength = 2;\n        break;\n\n      case '_':\n        // Try to find a blank node. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a blank node.\n        // Therefore, try inserting a space if we're at the end of the input.\n        if ((match = this._blank.exec(input)) ||\n            inputFinished && (match = this._blank.exec(input + ' ')))\n          type = 'blank', prefix = '_', value = match[1];\n        break;\n\n      case '\"':\n        // Try to find a literal without escape sequences\n        if (match = this._simpleQuotedString.exec(input))\n          value = match[1];\n        // Try to find a literal wrapped in three pairs of quotes\n        else {\n          ({ value, matchLength } = this._parseLiteral(input));\n          if (value === null)\n            return reportSyntaxError(this);\n        }\n        if (match !== null || matchLength !== 0) {\n          type = 'literal';\n          this._literalClosingPos = 0;\n        }\n        break;\n\n      case \"'\":\n        if (!this._lineMode) {\n          // Try to find a literal without escape sequences\n          if (match = this._simpleApostropheString.exec(input))\n            value = match[1];\n          // Try to find a literal wrapped in three pairs of quotes\n          else {\n            ({ value, matchLength } = this._parseLiteral(input));\n            if (value === null)\n              return reportSyntaxError(this);\n          }\n          if (match !== null || matchLength !== 0) {\n            type = 'literal';\n            this._literalClosingPos = 0;\n          }\n        }\n        break;\n\n      case '?':\n        // Try to find a variable\n        if (this._n3Mode && (match = this._variable.exec(input)))\n          type = 'var', value = match[0];\n        break;\n\n      case '@':\n        // Try to find a language code\n        if (this._previousMarker === 'literal' && (match = this._langcode.exec(input)))\n          type = 'langcode', value = match[1];\n        // Try to find a keyword\n        else if (match = this._keyword.exec(input))\n          type = match[0];\n        break;\n\n      case '.':\n        // Try to find a dot as punctuation\n        if (input.length === 1 ? inputFinished : (input[1] < '0' || input[1] > '9')) {\n          type = '.';\n          matchLength = 1;\n          break;\n        }\n        // Fall through to numerical case (could be a decimal dot)\n\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '+':\n      case '-':\n        // Try to find a number. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a number.\n        // Therefore, try inserting a space if we're at the end of the input.\n        if (match = this._number.exec(input) ||\n            inputFinished && (match = this._number.exec(input + ' '))) {\n          type = 'literal', value = match[0];\n          prefix = (typeof match[1] === 'string' ? xsd.double :\n                    (typeof match[2] === 'string' ? xsd.decimal : xsd.integer));\n        }\n        break;\n\n      case 'B':\n      case 'b':\n      case 'p':\n      case 'P':\n      case 'G':\n      case 'g':\n        // Try to find a SPARQL-style keyword\n        if (match = this._sparqlKeyword.exec(input))\n          type = match[0].toUpperCase();\n        else\n          inconclusive = true;\n        break;\n\n      case 'f':\n      case 't':\n        // Try to match a boolean\n        if (match = this._boolean.exec(input))\n          type = 'literal', value = match[0], prefix = xsd.boolean;\n        else\n          inconclusive = true;\n        break;\n\n      case 'a':\n        // Try to find an abbreviated predicate\n        if (match = this._shortPredicates.exec(input))\n          type = 'abbreviation', value = 'a';\n        else\n          inconclusive = true;\n        break;\n\n      case '=':\n        // Try to find an implication arrow or equals sign\n        if (this._n3Mode && input.length > 1) {\n          type = 'abbreviation';\n          if (input[1] !== '>')\n            matchLength = 1, value = '=';\n          else\n            matchLength = 2, value = '>';\n        }\n        break;\n\n      case '!':\n        if (!this._n3Mode)\n          break;\n      case ',':\n      case ';':\n      case '[':\n      case ']':\n      case '(':\n      case ')':\n      case '{':\n      case '}':\n        if (!this._lineMode) {\n          matchLength = 1;\n          type = firstChar;\n        }\n        break;\n\n      default:\n        inconclusive = true;\n      }\n\n      // Some first characters do not allow an immediate decision, so inspect more\n      if (inconclusive) {\n        // Try to find a prefix\n        if ((this._previousMarker === '@prefix' || this._previousMarker === 'PREFIX') &&\n            (match = this._prefix.exec(input)))\n          type = 'prefix', value = match[1] || '';\n        // Try to find a prefixed name. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a prefixed name.\n        // Therefore, try inserting a space if we're at the end of the input.\n        else if ((match = this._prefixed.exec(input)) ||\n                 inputFinished && (match = this._prefixed.exec(input + ' ')))\n          type = 'prefixed', prefix = match[1] || '', value = this._unescape(match[2]);\n      }\n\n      // A type token is special: it can only be emitted after an IRI or prefixed name is read\n      if (this._previousMarker === '^^') {\n        switch (type) {\n        case 'prefixed': type = 'type';    break;\n        case 'IRI':      type = 'typeIRI'; break;\n        default:         type = '';\n        }\n      }\n\n      // What if nothing of the above was found?\n      if (!type) {\n        // We could be in streaming mode, and then we just wait for more input to arrive.\n        // Otherwise, a syntax error has occurred in the input.\n        // One exception: error on an unaccounted linebreak (= not inside a triple-quoted literal).\n        if (inputFinished || (!/^'''|^\"\"\"/.test(input) && /\\n|\\r/.test(input)))\n          return reportSyntaxError(this);\n        else\n          return this._input = input;\n      }\n\n      // Emit the parsed token\n      var token = { line: line, type: type, value: value, prefix: prefix };\n      callback(null, token);\n      this.previousToken = token;\n      this._previousMarker = type;\n      // Advance to next part to tokenize\n      input = input.substr(matchLength || match[0].length, input.length);\n    }\n\n    // Signals the syntax error through the callback\n    function reportSyntaxError(self) { callback(self._syntaxError(/^\\S*/.exec(input)[0])); }\n  }\n\n  // ### `_unescape` replaces N3 escape codes by their corresponding characters\n  _unescape(item) {\n    let invalid = false;\n    const replaced = item.replace(escapeSequence, (sequence, unicode4, unicode8, escapedChar) => {\n      // 4-digit unicode character\n      if (typeof unicode4 === 'string')\n        return String.fromCharCode(Number.parseInt(unicode4, 16));\n      // 8-digit unicode character\n      if (typeof unicode8 === 'string') {\n        let charCode = Number.parseInt(unicode8, 16);\n        return charCode <= 0xFFFF ? String.fromCharCode(Number.parseInt(unicode8, 16)) :\n          String.fromCharCode(0xD800 + ((charCode -= 0x10000) >> 10), 0xDC00 + (charCode & 0x3FF));\n      }\n      // fixed escape sequence\n      if (escapedChar in escapeReplacements)\n        return escapeReplacements[escapedChar];\n      // invalid escape sequence\n      invalid = true;\n      return '';\n    });\n    return invalid ? null : replaced;\n  }\n\n  // ### `_parseLiteral` parses a literal into an unescaped value\n  _parseLiteral(input) {\n    // Ensure we have enough lookahead to identify triple-quoted strings\n    if (input.length >= 3) {\n      // Identify the opening quote(s)\n      const opening = input.match(/^(?:\"\"\"|\"|'''|'|)/)[0];\n      const openingLength = opening.length;\n\n      // Find the next candidate closing quotes\n      let closingPos = Math.max(this._literalClosingPos, openingLength);\n      while ((closingPos = input.indexOf(opening, closingPos)) > 0) {\n        // Count backslashes right before the closing quotes\n        let backslashCount = 0;\n        while (input[closingPos - backslashCount - 1] === '\\\\')\n          backslashCount++;\n\n        // An even number of backslashes (in particular 0)\n        // means these are actual, non-escaped closing quotes\n        if (backslashCount % 2 === 0) {\n          // Extract and unescape the value\n          const raw = input.substring(openingLength, closingPos);\n          const lines = raw.split(/\\r\\n|\\r|\\n/).length - 1;\n          const matchLength = closingPos + openingLength;\n          // Only triple-quoted strings can be multi-line\n          if (openingLength === 1 && lines !== 0 ||\n              openingLength === 3 && this._lineMode)\n            break;\n          this._line += lines;\n          return { value: this._unescape(raw), matchLength };\n        }\n        closingPos++;\n      }\n      this._literalClosingPos = input.length - openingLength + 1;\n    }\n    return { value: '', matchLength: 0 };\n  }\n\n  // ### `_syntaxError` creates a syntax error for the given issue\n  _syntaxError(issue) {\n    this._input = null;\n    var err = new Error('Unexpected \"' + issue + '\" on line ' + this._line + '.');\n    err.context = {\n      token: undefined,\n      line: this._line,\n      previousToken: this.previousToken,\n    };\n    return err;\n  }\n\n  // ## Public methods\n\n  // ### `tokenize` starts the transformation of an N3 document into an array of tokens.\n  // The input can be a string or a stream.\n  tokenize(input, callback) {\n    var self = this;\n    this._line = 1;\n\n    // If the input is a string, continuously emit tokens through the callback until the end\n    if (typeof input === 'string') {\n      this._input = input;\n      // If a callback was passed, asynchronously call it\n      if (typeof callback === 'function')\n        queueMicrotask(() => self._tokenizeToEnd(callback, true));\n      // If no callback was passed, tokenize synchronously and return\n      else {\n        var tokens = [], error;\n        this._tokenizeToEnd(function (e, t) { e ? (error = e) : tokens.push(t); }, true);\n        if (error) throw error;\n        return tokens;\n      }\n    }\n    // Otherwise, the input must be a stream\n    else {\n      this._input = '';\n      this._pendingBuffer = null;\n      if (typeof input.setEncoding === 'function')\n        input.setEncoding('utf8');\n      // Adds the data chunk to the buffer and parses as far as possible\n      input.on('data', function (data) {\n        if (self._input !== null && data.length !== 0) {\n          // Prepend any previous pending writes\n          if (self._pendingBuffer) {\n            data = Buffer.concat([self._pendingBuffer, data]);\n            self._pendingBuffer = null;\n          }\n          // Hold if the buffer ends in an incomplete unicode sequence\n          if (data[data.length - 1] & 0x80) {\n            self._pendingBuffer = data;\n          }\n          // Otherwise, tokenize as far as possible\n          else {\n            self._input += data;\n            self._tokenizeToEnd(callback, false);\n          }\n        }\n      });\n      // Parses until the end\n      input.on('end', function () {\n        if (self._input !== null)\n          self._tokenizeToEnd(callback, true);\n      });\n      input.on('error', callback);\n    }\n  }\n}\n","var RDF  = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n    XSD  = 'http://www.w3.org/2001/XMLSchema#',\n    SWAP = 'http://www.w3.org/2000/10/swap/';\n\nexport default {\n  xsd: {\n    decimal: XSD + 'decimal',\n    boolean: XSD + 'boolean',\n    double:  XSD + 'double',\n    integer: XSD + 'integer',\n    string:  XSD + 'string',\n  },\n  rdf: {\n    type:       RDF + 'type',\n    nil:        RDF + 'nil',\n    first:      RDF + 'first',\n    rest:       RDF + 'rest',\n    langString: RDF + 'langString',\n  },\n  owl: {\n    sameAs: 'http://www.w3.org/2002/07/owl#sameAs',\n  },\n  r: {\n    forSome: SWAP + 'reify#forSome',\n    forAll:  SWAP + 'reify#forAll',\n  },\n  log: {\n    implies: SWAP + 'log#implies',\n  },\n};\n"],"sourceRoot":""}